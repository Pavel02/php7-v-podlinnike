<?php
/**
 * Оригинальные листинги от автора в подкаталоге arrays
 *
 *
 * Массивы - это своеобразные контейнеры-переменные для хранения сразу нескольких величин,
 *   к которым можно затем быстро обратиться.
 * "Список" - массив в котором ключи идут с нуля без пропусков.
 *      listing-10-1    // Вывод массива на экран
 * 
 *      count();  и   sizeof();         // поред количество элементов массива
 *
 *                          Конструкция list.
 *  Задача: имеется некоторый массив список  $list  с тремя элементами: имя, фамилия, возраст.
 *      list ($name, $surname, $age) = $list;
 * Трем переменными соответственно присвоятся 3 первых значения в массиве.
 *      listing-10-construction-list        // пример конструкции list
 *
 * На самом деле все массивы (в том числе списки) это массивы асоциатиные.
 * Ассоциативне массивы являются направленными (существует определенный и предсказуемыйй порядок элементов).
 *
 *                          Конструкция Array и многомерные массивы.
 * Начиная с PHP 5.4  новый синтаксис.
 *      // Создает пустой массив $names
 *      $names = [];
 *      // Создаем ассоциативный массив
 *      $names = ["Weaving" => "Hugo", "Chong" => "Marcus"];
 *      // Создаем список с именами (нумерация 0, 1, 2)
 *      $nameList = ["Yen Wo Ping", "Geofrey Darrow", "Hugo Weaving"];
 *
 *
 *      // Создание многомерного массива
 *      $dossier["Anderson"] = ["name" => "Thomas", "born" = > "192-03-11"];
 *      $dossier["Reeves"] = ["name" => "Keanu", "born" => "192-09-02"];
 *
 *      // Или альтернативный синтаксис
 *      $dossier = [
 *          "Anderson" => ["name" => "Thomas", "born" => "1962-03-11"],
 *          "Reeves" => ["name" => "Keanu", "born" => "1962-09-02"],
 *      ];
 *
 *      // Обращение к элементу массива
 *      echo $dossier["Anderson"]["name"];      // Thomas
 *      echo $dossier["Reeves"]["diff"];      // Ошибка: нет элемента с ключом "diff"
 *
 *
 *                          Массивы-константы
 * Начиная с РНР 7, допскается создание констант-массивов
 *      define(
 *          'DOSSIER',
 *          [
 *              "Anderson" => ["name" => "Thomas", "born" => "1962-03-11"],
 *              "Reeves" => ["name" => "Keanu", "born" => "1962-09-02"],
 *          ]);
 *
 *
 *                          ОПЕРАЦИИ НАД МАССИВАМИ
 *                          Доступ по ключу.
 *      echo $names["Weaving"];     // Выводит элемент массива
 *      echo $dossier["Anderson"]["name"];      // Обращение к двумерному массиву
 * с PHP 5.4 можно так:
 *      echo SomeFuncThatReturnArray()[5];      // с PHP 5.4
 *
 *      $names["Davis"] = "Don";    // присваиваем элементу массива строку "Don"
 *      $ref = &$dossier["Reeves"]["name"]; // $ref - синоним элемента массива
 *      $nameList[] = "Paul Doyle";     // Добавляем новый элемент
 *
 *                          Функця count().
 *      count();    // стандартная функция, определяет размер (количестов элементов в массиве)
 *      $num = count($nameList);    // В $num будет количество элементов массива
 * count() применима также к объектам и даже к обычным переменым.
 *
 *
 *                          Слияние массивов.
 *      $good = ["Arahanga" => "Julian", "Doran" => "Matt"];
 *      $bad = ["Goddard" => "Paul", "Taylor" => "Robert"];
 *      $all = $good + $bad;
 *
 *                          Слияние списков.
 *      listing-10-2
 * При конкатенации массивов с некоторыми одинаковыми элементами (элементы с одинак ключами)
 *   в результирующем массиве останет один элемент (тот который был в первом массиве и на том же месте).
 *
 *
 *                          Косвенный перебор элементов массива.
 * Коссвенный перебор - это когда определяется вначале очередной ключ, а потом по нему косвенно
 *  находится значение элемента массива.
 *                          Перебор списка.
 *      // Пусть $nameList - список имен. Распечатаем их в столбик
 *      for ($i =0; $i < count($nameList); $i++)
 *          echo $nameList[$i] . "\n";
 *
 *      // Для перебора массива с конца
 *      for (end($birth); ($k = key($birth)); prev($birth))
 *          echo "$k родился {$birth[$k]}<br>";
 * Косвенный перебор имеет плюсы: 1. читабельность кода.
 *  2. Возможность перебора как в ту, так и в иную сторону.
 * Минусы косвенного перебора: 1. Мы не можем одновременно перебирать массив в двух вложенных
 *  циклах или функциях.
 *  2. Нулевой ключ. если $k = key($birth) будет значени 0, то массив прервется.
 *          listing-10-3        // пример перебора двумерного списка
 *
 *                          Перебор ассоциативного массива.
 *      listing-10-4
 * ислоьзованы функции  reset()   key()  next().
 * 
 * 
 *                              Прямой перебор массива.
 * Прямой перебор, это когда на каждом "витке" цикла одновременно получаем и ключ и значение текущего элемента.
 *
 *                              Старый способ
 *      for (reset($birth); list($k, $v) = each($birth);  ..здесь_пусто..)
 *          echo "$k родился $v <br />";
 *
 *                              Перебор циклом  foreach.
 *      foreach ($birth as $k => $v)
 * Перед началом своей работы цикл  foreach  создает копию массива и работает с копией.
 *      listing-10-5        // изменив копию массива внутри цикла, исходный массив остался без изменений.
 *      listing-10-6        // & - используя ссылку на массив
 *
 *
 *                              Списки и строки.
 *      list explode(string $token, string $str [, int $limit])
 *  функция  explode получает строку $str, ищет в ней подстроку $token,
 *   затем по месту вхождения этих подстрок, строка $str  разреазется на массив-список.
 *          $st = "457219361|Thomas Anderson|1962-03-11|Текст, содержащий (|)!";
 *          $person = explode("|", $st, 4)      // Мы знаем, что там только 4 поля.
 *          // Распределяем по переменным:
 *          list ($id, $name, $burn, $comment) = $person;
 *
 *
 *      sring implode(string $glue, list $list);
 * или
 *      sring join(string $glue, list $list);
 * Здесь берется ассоциативный массив  $list (обычно это список) и склеивают его значения
 *  вставляя разделитель $glue.
 *
 *                              Сериализация.
 * Упаковка массива в файл, а потом счтываие его оттуда.
 *                              Упаковка
 *      string serialize(mixed $obj);
 * функция фозвращает строку, являющуюся упакованным эквивалентом некоего объекта $obj (массив, целое число ...)
 *                              Распаковка.
 *      mixed unserialize(string $st);
 * функция принимает строку  $st, ранее созданную при помощи serialize(), и возвращает объект, который был раньше упакован.
 *      listing-10-7
 *  
 *
 *
 * 
 *
 *
 * 
 */